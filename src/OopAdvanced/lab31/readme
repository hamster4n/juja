В порт заходит большое количество разных кораблей. Для работы с ними был разработан базовый
абстрактный класс AbstractShip, который включает в себя все параметры, которые имеет каждый корабль:
длинна (Length), ширина (Width), водоизмещение (displacement) и несколько методов для получения информации
про корабль. В этом классе описан абстрактный метод calculatePayment(), который производит расчет оплаты
за обслуживание портом разных типов кораблей. Порт приинимает следующие типы кораблей: лайнеры (Liner),
танкеры (Tanker), грузовые (Cargo).

Для обобщения принципов работы очереди кораблей в порту был разработан интерфейс SeaPortQueue.

Необходимо реализовать этот интерфейс для конкретного порта в виде класса OdessaSeaPort.
В качестве структуры данных для очереди кораблей используйте массив типа AbstractShip и переменную
indexShipInPort типа int, которая хранит индекс последнего корабля в очереди. В начале работы
indexShipInPort равна константе NO_SHIP_IN_ARRAY = -1. Размер очереди порта равняется константе
LENGTH_QUEUE_SHIP=3 из интерфейса SeaPortQueue.

addShipToEndQueue() - метод, который добавляет корабль в конец очереди. Если очередь полная
необходимо вернуть -1. Если корабль успешно добавлен в очередь, необходимо вернуть его индекс в массиве очереди.

removeShipFromBeginQueue() - метод, который удаляет корабль из начала очереди. Если очередь
пуста необходимо вернуть -1. Если корабль успешно удален вернуть 1. При удалении корабля обеспечить
продвижение кораблей в начало очереди.  (Подсказка: очередь - массив, поэтому можно использовать
методы из стандартных пакетов для работы с массивами)

printQueueShip() - метод, который печатает информацию про корабли в очереди. Если в очереди нет
кораблей вернуть строку "QueueEmpty", иначе на выходе ожидается строка в виде конкатенации печати
информации о корабле. Выходная строка имеет следующий вид: {Name=<>Length=<>Width=<>Displacement=<>};
{Name=<>Length=<>Width=<>Displacement=<>};